#不良的测试实践

时至今日，我写自动化测试也已经有些年头了。本文中，我希望分享一些我的经验，以及我从其他人和反复试错中获取的教训。

这些年，我听到了许多关于写自动化测试的好的(或者不好的)理由。从积极的方面来说，写自动化测试能够:

使重构更简单
避免回归
提供了可执行的说明和文档
减少了创建软件的时间
降低了创建软件的代价

的确，你可以说这些都是对的，但是我想提出一个关于这些理由的另一个视角——一个统一的视角

`自动化测试唯一有价值的理由是允许我们在将来修改我们的代码`

换句话说:
`一个测试能够体现价值的时候仅仅是当我们想修改我们的代码的时候`

让我们看一看这个经典论断是如何支持我们前面提到的理由的

使重构更简单——你可以自信的修改实现细节，而不用去触碰公共的API
避免回归——回归在什么时候发生？在你修改代码的时候
提供了可执行的说明和文档——你想在什么时候知道更多的软件实际上是如何工作的？在你想修改他们的时候
减少了创建软件的时间——怎么减少时间的？是通过更快速地修改你的代码，当出错的时候测试会告诉的这份自信
降低了创建软件的代价——好吧，时间就是金钱


是的，上面所有的理由在某些方面是对的，但是这些理由适用于我们开发者的是自动化测试能够让我们修改东西。

注意，我没有包括写测试的设计反馈，比如TDD。那可以成为一个单独的话题。我们将要谈论的测试是写好的测试。

看起来好像写测试和如何写测试应该由修改作为动机。

一个简单的考虑这个问题的方法是在写测试的时候，向你的测试提出下面两个问题:
"如果我修改了我的生产代码，你们是会失败(还是通过)呢?"
"那是一个让你们失败(或者通过)的好的理由么?"

如果你发现了测试失败(或者通过)的不好的理由，那么请修正它




##修改代码的行为
起点必须全部是绿色，也就是说所有的测试都应该通过。

如果你想修改你的代码来修改它们的行为(也就是，修改你的代码做的事情)，你需要：
1. 找到定义当前行为的测试
2. 修改这些测试来满足期望的行为
3. 运行测试，查看那些修改过的测试是否失败了
4. 更新你的代码，是的所有的测试重新通过

在这一过程的最后，我们又回到了起点——所有的测试都通过了，如果需要，我们准备好了再次开始。

因为你知道哪些测试失败了以及哪些代码的修改使得他们通过了，你会很有信心，因为你只修改了你想要修改的部分。
这就是自动化测试怎样帮助我们，通过修改我们的代码来改变行为的 方法。

注意，看到一个测试失败是 OK 的，因为她是我们更新行为相关的测试



##重构：修改代码的实现——保持行为不变
同样，起点应该是绿色。

如果你们想要的是，修改一段代码的实现让它变得更简单，高效，易于扩展等等(也就是说，修改怎么做，而不是做什么)，应该遵循接下来的详细的步骤：
1. 在不触碰你的测试的前提下修改你的代码
   暂时不会。在重构的时候，测试应该只在代码出错的时候失败，例如修改了代码的外部行为。当发生这种情况时，你应该回到那个错误然后回到绿色的状态
   
   因为你的测试总是在绿色的状态，你知道你没有破坏任何事情。这就是自动化测试如何让我们修改我们的代码的方式。
   
   在这种情况下，看到测试失败是不 OK 的。因为这意味着：
   
   . 我们无意地修改了代码的外部行为。庆幸的是，我们的测试帮助了我们发现这些错误
   . 我们没有修改代码的外部行为。太不幸了，我们失败了。这才是真正的麻烦
   
   我希望我们的测试在上面的情形下能够帮助我们。所以让我们来看一些具体的能让我们的测试更有效的 tips 



###优秀实践 101

$$$$$有问题，我想很快地回顾一些优秀实践。有5条每个测试都应该遵守的且被认为是优秀的基本规则。有一个便于记忆这5条规则的缩写 F.I.R.S.T.

测试应该：
快速(Fast)——测试应该能够被反复执行
隔离(Isolated)——测试本身不能依赖于外部因素或者其他测试的结果
可重复(Repeatable)——每次运行测试都应该产生相同的结果
自检(Self-verifying)——测试应该包括断言(assertions)，不需要人为干预
及时(Timely)——测试应该和生产代码一同书写

更多关于这些规则的内容，你可以阅读 Tim Ottinger 和 Jeff Langr 的这篇文章[http://pragprog.com/magazines/2012-01/unit-tests-are-first]



###不佳实践
我们如何将测试输出的收益最大化？一言以蔽之:
`不要将测试和实现细节连接在一起`

####不要测试私有方法

说的够多了。












































