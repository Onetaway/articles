#糟糕的测试

时至今日，我写自动化测试也已经有些年头了。本文中，我希望分享一些我的经验，以及我从其他人和反复试错中获取的教训。

这些年，我听到了许多关于写自动化测试的好的(或者不好的)理由。从积极的方面来说，写自动化测试能够:

使重构更简单
避免回归
提供了可执行的说明和文档
减少了创建软件的时间
降低了创建软件的代价

的确，你可以说这些都是对的，但是我想提出一个关于这些理由的另一个视角——一个统一的视角

`自动化测试唯一有价值的理由是允许我们在将来修改我们的代码`

换句话说:
`一个测试能够体现价值的时候仅仅是当我们想修改我们的代码的时候`

让我们看一看这个经典论断是如何支持我们前面提到的理由的

使重构更简单——你可以自信的修改实现细节，而不用去触碰公共的API
避免回归——回归在什么时候发生？在你修改代码的时候
提供了可执行的说明和文档——你想在什么时候知道更多的软件实际上是如何工作的？在你想修改他们的时候
减少了创建软件的时间——怎么减少时间的？是通过更快速地修改你的代码，当出错的时候测试会告诉的这份自信
降低了创建软件的代价——好吧，时间就是金钱


是的，上面所有的理由在某些方面是对的，但是这些理由适用于我们开发者的是自动化测试能够让我们修改东西。

注意，我没有包括写测试的设计反馈，比如TDD。那可以成为一个单独的话题。我们将要谈论的测试是写好的测试。

看起来好像写测试和如何写测试应该由修改作为动机。

一个简单的考虑这个问题的方法是在写测试的时候，向你的测试提出下面两个问题:
"如果我修改了我的生产代码，你们是会失败(还是通过)呢?"
"那是一个让你们失败(或者通过)的好的理由么?"

如果你发现了测试失败(或者通过)的不好的理由，那么请修正它




##修改代码的行为
起点必须全部是绿色，也就是说所有的测试都应该通过。

如果你想修改你的代码来修改它们的行为(也就是，修改你的代码做的事情)，你需要：
1. 找到定义当前行为的测试
2. 修改这些测试来满足期望的行为
3. 运行测试，查看那些修改过的测试是否失败了
4. 更新你的代码，是的所有的测试重新通过

在这一过程的最后，我们又回到了起点——所有的测试都通过了，如果需要，我们准备好了再次开始。

因为你知道哪些测试失败了以及哪些代码的修改使得他们通过了，你会很有信心，因为你只修改了你想要修改的部分。
这就是自动化测试怎样帮助我们，通过修改我们的代码来改变行为的 方法。

注意，看到一个测试失败是 OK 的，因为她是我们更新行为相关的测试



##重构：修改代码的实现——保持行为不变
同样，起点应该是绿色。

如果你们想要的是，修改一段代码的实现让它变得更简单，高效，易于扩展等等(也就是说，修改怎么做，而不是做什么)，应该遵循接下来的详细的步骤：
1. 在不触碰你的测试的前提下修改你的代码
   暂时不会。在重构的时候，测试应该只在代码出错的时候失败，例如修改了代码的外部行为。当发生这种情况时，你应该回到那个错误然后回到绿色的状态
   
   因为你的测试总是在绿色的状态，你知道你没有破坏任何事情。这就是自动化测试如何让我们修改我们的代码的方式。
   
   在这种情况下，看到测试失败是不 OK 的。因为这意味着：
   
   . 我们无意地修改了代码的外部行为。庆幸的是，我们的测试帮助了我们发现这些错误
   . 我们没有修改代码的外部行为。太不幸了，我们失败了。这才是真正的麻烦
   
   我希望我们的测试在上面的情形下能够帮助我们。所以让我们来看一些具体的能让我们的测试更有效的 tips 



###优秀实践 101

$$$$$有问题，我想很快地回顾一些优秀实践。有5条每个测试都应该遵守的且被认为是优秀的基本规则。有一个便于记忆这5条规则的缩写 F.I.R.S.T.

测试应该：
快速(Fast)——测试应该能够被反复执行
隔离(Isolated)——测试本身不能依赖于外部因素或者其他测试的结果
可重复(Repeatable)——每次运行测试都应该产生相同的结果
自检(Self-verifying)——测试应该包括断言(assertions)，不需要人为干预
及时(Timely)——测试应该和生产代码一同书写

更多关于这些规则的内容，你可以阅读 Tim Ottinger 和 Jeff Langr 的这篇文章[http://pragprog.com/magazines/2012-01/unit-tests-are-first]



###不佳实践
我们如何将测试输出的收益最大化？一言以蔽之:
`不要将测试和实现细节连接在一起`

####不要测试私有方法

说的够多了。

###如果你去除(Stub Out)了一个依赖，那么请正确地使用
注：stub——人为地让一个对象对某个方法返回我们事先规定好的值

这部分和前一点关系密切，但是这部分更普遍。我们的生产代码通常依赖于某些事情的完成。比如，一个依赖能够帮助我们查询数据库。通常这些依赖提供了多种方法来实现相同的事情，或者说至少是相同的外部行为；在我们的数据库的例子中，你可以使用 find 方法通过 ID 来获取一条记录，或者使用 where 子句获取相同的记录。当我们仅仅 stub 可能的机制中的一个的时候，问题就出现了。如果我们仅仅 stub 了 find 方法(我们的生产代码使用的机制)，但是没有 stub 其他的可能性，比如 where 子句，当我们决定使用 where 子句取代 find 方法来重构我们的实现的时候，我们的测试就会失败，即使代码的外部行为并没有修改。

今天：UsersController 类依赖于 UserRepository 类从数据库中取得用户。你正在测试 UsersController 并且你 stub out 了 UsersRepository 的 find 方法


###不要测试构造函数
构造函数是被定义的实现细节，你不应该测试构造函数，这是因为我们认同测试应该与实现细节解藕这一观点。

而且，构造函数不应该包含行为，所以没有值得测试的东西。这是因为我们认同应该只测试代码的行为这一观点。

今天：你有一个 Car 类，该类没有构造函数。一旦一个 Car 被创建了，你测试它的 Engine 不为空(因为你知道构造函数创建了一个新的 Engine 并将它赋给了变量 _engine)

明天：Engine 类变得创建起来代价很高，所以你决定使用延迟加载(注：字面意思是延迟初始化)(lazily initialize)在调用 Engine 的 getter 方法时才第一次初始化 Engine.(这是一个完全没有问题对额事情。) 现在你为 Car 类的构造函数编写的测试出问题了，即便 Car 类运行良好，Car 并没有包括 Engine.另一个可选的理由是你的测试不会失败，因为测试包括 Engine 的 Car 类会触发 Engine 的延迟加载。所以我的问题是：为什么还要测试？

应该做什么：当使用不同的方法创建类的时候测试公有 API 的行为。一个愚蠢的例子：测试当 list 被创建并且没有条目的时候，list 类的 count 方法的行为。注意你测试的是 count 的行为而不是构造函数的行为

假如你的类含有多个构造函数，注意！！！稍微思考一下。你的类可能做了太多事情了。试着将它们拆分成更小的类，但是如果有足够充分的理由使你的类含有多个构造函数，那么依然遵循同样的建议。保证你的测试的是那个类的公有 API。在这种情况下，使用每一个构造函数去测试(也就是说，当类处在一种初始化状态下时，它的行为就是那种状态下的；当类处在另一种初始化状态下时，它的行为就是另一种状态下的)


##结论
编写测试是一项投资——我们需要花时间编写和维护它们。我们可以证明这种投资有回报的唯一方法就是我们期望节省时间。实现细节的耦合的测试会减少测试提供的价值，使得那些投资变得不合算，甚至在某些情况下变得一文不值。

在编写测试、重构以及修改系统行为的时候，检查你的测试在面对错误的原因时是失败还是通过，然后退一步问问自己，那些测试是否能够最大化你投资的成果。








































